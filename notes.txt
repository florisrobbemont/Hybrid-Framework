- Be aware of IEnumerable's multiple iterations. If you have a LINQ query over, and get it as an IEnumerable, always toList() is when you're going to use it.
  Otherwise you'll get multiple enumerations (IE: the linq query is executed every time you access is => .Count(), .Skip() etc).

- Don't use string comparison with the .ToLower() method. This is slow and will also NOT work when using other languages. (Like the Arabic letter i).
  Instead of writing: if(custom.ToLower() == "url")
  Do: if(custom.Equals("url", StringComparison.OrdinalIgnoreCase))

- DEV Tip: Extension methods should be used to extend the class the're written for. Using an extension method as a place to put code can bite you in the long run.
           For example: The UmbracoHelper class is used for Umbraco methods. When you extend that class, it should only be to used for that class.

- It's better to use NuGet package restore then to include all DLL's in your repository. This way the repo stays small.
  I've replaced the .gitignore file with ours. We exclude certain files from the web project's BIN folder manually.

- I've removed both projects from your solution. My view is that an Umbraco solution should reflect a 'good' project structure:
	- UmbracoProject (CORE layer, contains all code that is needed to make your application run)
	- UmbracoProject.Common (All non-logic utilities without dependencies go here)
	- UmbracoProject.Data (Create if necessary, when your data code is becoming more then just a simple class)
	- UmbracoProject.Web (MVC site which holds the Umbraco DLL's and website. No other project in the solution should know about the Umbraco DLL's)
  This structure will allow you to better seperate the Web world from the actual code world and create better code (more seperated from your web project).
  The container will help you to bring this all together

- I've copied all the files from your original Umbraco project to the new one. All packages and settings should work.

- DEV Tip: Don't use so many regions unless it's absolutely necessary. Using regions makes it harder to read a class.
           If the class becomes big enough to use regions, you're putting too much code into one class ;)
	   Because of this I've removed all regions in the code I've changed. You can see the difference in readability.

- (From the SOLID books and the coding guidelines that are inspired by SOLID. These are are the ones we use: http://csharpguidelines.codeplex.com/):
  A class or interface should have a single purpose within the system it participates in. 
  In general, a class is either representing a primitive type like an email or ISBN number, an abstraction of some business concept, 
  a plain data structure or responsible for orchestrating the interaction between other classes. It is never a combination of those. 
  This rule is widely known as the Single Responsibility Principle, one of the SOLID principles.

  Tip: A class with the word And in it is an obvious violation of this rule.
  Tip: Use Design Patterns to communicate the intent of a class. If you can’t assign a single design pattern to a class, chances are that it is doing more than one thing.
  Note: If you create a class representing a primitive type you can greatly simplify it usage by making it immutable.

- I've added my Kernel system to your codebase. This system is nothing more then an eventing system that allows you to run events throughout your code.
  It comes with 2 events as standard: Startup, Shutdown. These events are hooked into Umbraco. This removes the need for multiple ApplicationEvents classes.
  It also allows you to add groups of events. For example, you're building some syncing system that has multiple categories: Products, Categories, Customers etc.
  You would have the following events:
	- ProductsSync
	- CategoriesSync
	- CustomersSync
	- etc
  All these events can be run manually using the IKernelContext interface. You can also create a group, for example: Syncers. 
  Using the same interface your can call: RunKernelEventGroup('Syncers'), and it will run all the events from the group.

- I've moved the bundle configuration to their own interface (IBundleConfiguration). You now have a class for each configuration

- I've removed the Singleton<> class since this is now all managed by the IoC container.

- I've splitted up the class called: ExtensionMethods into different categories. They are spread out throughout the application based on their extension.

- TODO:
	- Email
	- Sitemap
	- News
	- View Compilation
	- Contact form





