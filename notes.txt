- Be aware of IEnumerable's multiple iterations. If you have a LINQ query over, and get it as an IEnumerable, always toList() is when you're going to use it.
  Otherwise you'll get multiple enumerations (IE: the linq query is executed every time you access is => .Count(), .Skip() etc).

- It's better to use NuGet package restore then to include all DLL's in your repository. This way the repo stays small.
  I've replaced the .gitignore file with ours. We exclude certain files from the web project's BIN folder manually.

- I've removed both projects from your solution. My view is that an Umbraco solution should reflect a 'good' project structure:
	- UmbracoProject (CORE layer, contains all code that is needed to make your application run)
	- UmbracoProject.Common (All non-logic utilities without dependencies go here)
	- UmbracoProject.Data (Create if necessary, when your data code is becoming more then just a simple class)
	- UmbracoProject.Web (MVC site which holds the Umbraco DLL's and website. No other project in the solution should know about the Umbraco DLL's)
  This structure will allow you to better seperate the Web world from the actual code world and create better code (more seperated from your web project).
  The container will help you to bring this all together

- I've copied all the files from your original Umbraco project to the new one. All packages and settings should work.

- DEV Tip: Don't use so many regions unless it's absolutely necessary. Using regions makes it harder to read a class.
           If the class becomes big enough to use regions, you're putting too much code into one class ;)
	   Because of this I've removed all regions in the code I've changed. You can see the difference in readability.

- (From the SOLID books and the coding guidelines that are inspired by SOLID. These are are the ones we use: http://csharpguidelines.codeplex.com/):
  A class or interface should have a single purpose within the system it participates in. 
  In general, a class is either representing a primitive type like an email or ISBN number, an abstraction of some business concept, 
  a plain data structure or responsible for orchestrating the interaction between other classes. It is never a combination of those. 
  This rule is widely known as the Single Responsibility Principle, one of the SOLID principles.

  Tip: A class with the word And in it is an obvious violation of this rule.
  Tip: Use Design Patterns to communicate the intent of a class. If you can’t assign a single design pattern to a class, chances are that it is doing more than one thing.
  Note: If you create a class representing a primitive type you can greatly simplify it usage by making it immutable.

- 


- TODO:
	- Email
	- Sitemap
	- News
	- View Compilation
	- Contact form





